/**
 * This module was automatically generated by `ts-interface-builder`
 */
import * as t from 'ts-interface-checker';
// tslint:disable:object-literal-key-quotes

export const JSONValue = t.union(
    'string',
    'number',
    'boolean',
    'undefined',
    t.iface([], {
        [t.indexKey]: 'JSONValue',
    }),
    t.array('JSONValue')
);

export const JSONObject = t.name('any');

export const RPCMessage = t.iface([], {
    jsonrpc: t.lit('2.0'),
    method: 'string',
    params: 'JSONObject',
    id: 'number',
});

export const RPCResult = t.iface([], {
    jsonrpc: t.lit('2.0'),
    result: t.iface([], {
        value: 'boolean',
    }),
    id: 'number',
    error: t.union('JSONObject', 'JSONValue'),
});

export const ValidationType = t.union(t.lit('none'), t.lit('normal'));

export const ValidateParams = t.union('any', t.array('any'));

export const Timestamp = t.union('string', 'number', 'Date');

export const LogValue = t.iface([], {
    timestamp: 'Timestamp',
    data: t.union('string', 'number'),
});

export const InitialState = t.union('string', 'number', 'LogValue');

export const LogValues = t.array('LogValue');

export const ValuePermission = t.union(
    t.lit('r'),
    t.lit('w'),
    t.lit('rw'),
    t.lit('wr')
);

export const StateType = t.union(t.lit('Report'), t.lit('Control'));

export const StateStatus = t.union(
    t.lit('Send'),
    t.lit('Pending'),
    t.lit('Failed')
);

export const EventLogLevel = t.union(
    t.lit('important'),
    t.lit('error'),
    t.lit('success'),
    t.lit('warning'),
    t.lit('info'),
    t.lit('debug')
);

export const LogOperation = t.union(
    t.lit('arbitrary'),
    t.lit('array_agg'),
    t.lit('avg'),
    t.lit('mean'),
    t.lit('count'),
    t.lit('geometric_mean'),
    t.lit('max'),
    t.lit('min'),
    t.lit('sqrdiff'),
    t.lit('stddev'),
    t.lit('sum'),
    t.lit('variance'),
    t.lit('harmonic_mean'),
    t.lit('first'),
    t.lit('last'),
    t.lit('count_distinct'),
    t.lit('median'),
    t.lit('percentile'),
    t.lit('lower_quartile'),
    t.lit('upper_quartile'),
    t.lit('mode')
);

export const EventType = t.union(
    t.lit('create'),
    t.lit('update'),
    t.lit('delete'),
    t.lit('direct')
);

export const Mail = t.iface([], {
    body: 'string',
    subject: 'string',
    from: 'string',
});

export const FilterOperatorType = t.union(
    t.lit('='),
    t.lit('!='),
    t.lit('=='),
    t.lit('<'),
    t.lit('<='),
    t.lit('>'),
    t.lit('>='),
    t.lit('~'),
    t.lit('!~')
);

export const FilterValueOperatorType = t.iface([], {
    operator: 'FilterOperatorType',
    value: t.union('string', t.array('string'), 'number', t.array('number')),
});

export const FilterValueType = t.union(
    'string',
    t.array('string'),
    'number',
    t.array('number'),
    'FilterValueOperatorType',
    'undefined'
);

export const Connection = t.iface([], {
    timestamp: t.opt('string'),
    online: t.opt('boolean'),
});

export const ParentName = t.iface([], {
    network: t.opt('string'),
    device: t.opt('string'),
    value: t.opt('string'),
});

export const Meta = t.iface([], {
    id: t.opt('string'),
    type: t.opt('string'),
    version: t.opt('string'),
    redirect: t.opt('string'),
    manufacturer: t.opt('string'),
    iot: t.opt('boolean'),
    upgradable: t.opt('boolean'),
    connection: t.opt('Connection'),
    stable_connection: t.opt('Connection'),
    created: t.opt('string'),
    updated: t.opt('string'),
    revision: t.opt('number'),
    changed: t.opt('string'),
    owner: t.opt('string'),
    size: t.opt('number'),
    path: t.opt('string'),
    parent: t.opt('string'),
    parent_name: t.opt('ParentName'),
    parent_name_by_user: t.opt('ParentName'),
    usage_daily: t.opt('any'),
    product: t.opt('string'),
    deprecated: t.opt('boolean'),
    icon: t.opt('string'),
    historical: t.opt('boolean'),
    name_by_user: t.opt('string'),
    tag: t.opt(t.array('string')),
    tag_by_user: t.opt(t.array('string')),
});

export const MetaItem = t.iface([], {
    meta: 'Meta',
});

export const FetchRequest = t.iface([], {
    endpoint: 'string',
    params: t.opt('JSONObject'),
    body: t.opt('JSONObject'),
    throw_error: t.opt('boolean'),
    go_internal: t.opt('boolean'),
});

export const AnalyticsResponse = t.name('any');

export const NotificationCustomData = t.iface([], {
    all: 'boolean',
    future: 'boolean',
    selected: t.array(
        t.iface([], {
            meta: t.iface([], {
                id: 'string',
            }),
        })
    ),
});

export const NotificationCustom = t.iface([], {
    type: 'string',
    quantity: 'number',
    limitation: t.array('JSONObject'),
    method: t.array('JSONObject'),
    option: 'JSONObject',
    message: 'string',
    name_installation: 'string',
    title_installation: t.union('string', 'null'),
    data: t.opt('NotificationCustomData'),
});

export const NotificationBase = t.iface([], {
    action: 'string',
    code: 'number',
    type: 'string',
    from: 'string',
    to: 'string',
    from_type: 'string',
    from_name: 'string',
    to_type: 'string',
    type_ids: 'string',
    priority: 'number',
    ids: t.array('string'),
    info: t.array('JSONObject'),
    identifier: 'string',
});

export const LogGroupBy = t.union(
    t.lit('year'),
    t.lit('quarter'),
    t.lit('month'),
    t.lit('week'),
    t.lit('day'),
    t.lit('hour'),
    t.lit('minute'),
    t.lit('second'),
    t.lit('millisecond'),
    t.lit('microsecond'),
    t.lit('dow'),
    t.lit('doy')
);

export const LogRequest = t.iface([], {
    start: t.opt(t.union('Date', 'string')),
    end: t.opt(t.union('Date', 'string')),
    limit: t.opt('number'),
    offset: t.opt('number'),
    operation: t.opt('LogOperation'),
    group_by: t.opt('LogGroupBy'),
    timestamp_format: t.opt('string'),
    timezone: t.opt('string'),
    order: t.opt(t.union(t.lit('ascending'), t.lit('descending'))),
    order_by: t.opt('string'),
    number: t.opt('boolean'),
    all: t.opt('boolean'),
});

export const ExternalLogValues = t.iface([], {
    meta: 'Meta',
    more: 'boolean',
    type: 'string',
    data: t.array(
        t.iface([], {
            timestamp: 'string',
            time: 'string',
            data: 'string',
            [t.indexKey]: 'string',
        })
    ),
});

export const OtherContact = t.iface([], {
    contact: 'string',
    status: t.union(
        t.lit('pending'),
        t.lit('refused'),
        t.lit('accepted'),
        t.lit('send'),
        t.lit('not_sent'),
        t.lit('archive')
    ),
    contact_message: 'string',
    language: 'string',
    last_update: t.opt('string'),
});

export const UserDailyLimit = t.iface([], {
    point: t.opt('number'),
    document: t.opt('number'),
    log_row: t.opt('number'),
    traffic: t.opt('number'),
    iot_traffic: t.opt('number'),
    stream_traffic: t.opt('number'),
    file: t.opt('number'),
    request: t.opt('number'),
    request_time: t.opt('number'),
});

export const NetworkDailyLimit = t.iface([], {
    point: t.opt('number'),
    iot_traffic: t.opt('number'),
    request: t.opt('number'),
    request_time: t.opt('number'),
});

export const PointManagement = t.iface([], {
    base_point: t.opt('any'),
    base_network: t.opt('any'),
    user_daily_limit: t.opt('UserDailyLimit'),
    network_daily_limit: t.opt('NetworkDailyLimit'),
});

const exportedTypeSuite: t.ITypeSuite = {
    JSONValue,
    JSONObject,
    RPCMessage,
    RPCResult,
    ValidationType,
    ValidateParams,
    Timestamp,
    LogValue,
    InitialState,
    LogValues,
    ValuePermission,
    StateType,
    StateStatus,
    EventLogLevel,
    LogOperation,
    EventType,
    Mail,
    FilterOperatorType,
    FilterValueOperatorType,
    FilterValueType,
    Connection,
    ParentName,
    Meta,
    MetaItem,
    FetchRequest,
    AnalyticsResponse,
    NotificationCustomData,
    NotificationCustom,
    NotificationBase,
    LogGroupBy,
    LogRequest,
    ExternalLogValues,
    OtherContact,
    UserDailyLimit,
    NetworkDailyLimit,
    PointManagement,
};
export default exportedTypeSuite;
