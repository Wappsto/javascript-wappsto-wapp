/**
 * This module was automatically generated by `ts-interface-builder`
 */
import * as t from 'ts-interface-checker';
// tslint:disable:object-literal-key-quotes

export const IConnection = t.iface([], {
    timestamp: 'string',
    online: 'boolean',
});

export const IMeta = t.iface([], {
    id: t.opt('string'),
    type: t.opt('string'),
    version: t.opt('string'),
    redirect: t.opt('string'),
    manufacturer: t.opt('string'),
    iot: t.opt('boolean'),
    upgradable: t.opt('boolean'),
    connection: t.opt('IConnection'),
    created: t.opt('string'),
    updated: t.opt('string'),
    revision: t.opt('number'),
    changed: t.opt('string'),
    owner: t.opt('string'),
    size: t.opt('number'),
    path: t.opt('string'),
    parent: t.opt('string'),
    usage_daily: t.opt('any'),
    product: t.opt('string'),
    deprecated: t.opt('boolean'),
    icon: t.opt('string'),
    trace: t.opt('string'),
});

export const INetwork = t.iface([], {
    name: 'string',
    description: t.opt('string'),
});

export const INetworkFunc = t.iface([], {
    constructor: t.func('void', t.param('name', 'string', true)),
    createNetwork: t.func(
        'INetwork',
        t.param('name', t.union('string', 'INetwork')),
        t.param('description', t.union('string', 'undefined'))
    ),
    findDeviceByName: t.func(t.array('IDevice'), t.param('name', 'string')),
    findValueByName: t.func(t.array('IValue'), t.param('name', 'string')),
    findValueByType: t.func(t.array('IValue'), t.param('type', 'string')),
    createDevice: t.func('IDevice', t.param('params', 'IDevice')),
    find: t.func(
        t.array('INetwork'),
        t.param('params', 'any'),
        t.param('quantity', t.union('number', t.lit('all'))),
        t.param('usage', 'string')
    ),
    findByName: t.func(
        t.array('INetwork'),
        t.param('name', 'string'),
        t.param('quantity', t.union('number', t.lit('all'))),
        t.param('usage', 'string')
    ),
    findAllByName: t.func(
        t.array('IDevice'),
        t.param('name', 'string'),
        t.param('usage', 'string')
    ),
    fetch: t.func(
        'IDevice',
        t.param('name', 'string'),
        t.param('params', 'any')
    ),
});

export const IDevice = t.iface([], {
    name: 'string',
    product: t.opt('string'),
    serial: t.opt('string'),
    description: t.opt('string'),
    protocol: t.opt('string'),
    communication: t.opt('string'),
    version: t.opt('string'),
    manufacturer: t.opt('string'),
});

export const IDeviceFunc = t.iface([], {
    constructor: t.func('void', t.param('name', 'string', true)),
    findValueByName: t.func(t.array('IValue'), t.param('name', 'string')),
    findValueByType: t.func(t.array('IValue'), t.param('type', 'string')),
    createValue: t.func('IValue', t.param('params', 'IValue')),
    createNumberValue: t.func(
        'IValue',
        t.param('params', t.intersection('IValue', 'IValueNumber'))
    ),
    createStringValue: t.func(
        'IValue',
        t.param('params', t.intersection('IValue', 'IValueString'))
    ),
    createBlobValue: t.func(
        'IValue',
        t.param('params', t.intersection('IValue', 'IValueBlob'))
    ),
    createXmlValue: t.func(
        'IValue',
        t.param('params', t.intersection('IValue', 'IValueXml'))
    ),
    find: t.func(
        t.array('IDevice'),
        t.param('params', 'any'),
        t.param('quantity', t.union('number', t.lit('all'))),
        t.param('usage', 'string')
    ),
    findByName: t.func(
        t.array('IDevice'),
        t.param('name', 'string'),
        t.param('quantity', t.union('number', t.lit('all'))),
        t.param('usage', 'string')
    ),
    findAllByName: t.func(
        t.array('IDevice'),
        t.param('name', 'string'),
        t.param('usage', 'string')
    ),
    findByProduct: t.func(
        t.array('IDevice'),
        t.param('product', 'string'),
        t.param('quantity', t.union('number', t.lit('all'))),
        t.param('usage', 'string')
    ),
    findAllByProduct: t.func(
        t.array('IDevice'),
        t.param('product', 'string'),
        t.param('usage', 'string')
    ),
});

export const IPermissionModelFunc = t.iface([], {
    request: t.func(
        t.array('any'),
        t.param('endpoint', 'string'),
        t.param('quantity', t.union('number', t.lit('all'))),
        t.param('message', 'string'),
        t.param('params', 'any', true)
    ),
});

export const IModelFunc = t.iface([], {
    create: t.func('void', t.param('params', 'any')),
    fetch: t.func(
        t.array('any'),
        t.param('endpoint', 'string'),
        t.param('params', 'any', true)
    ),
    parse: t.func('boolean', t.param('json', 'any')),
});

export const IValue = t.iface([], {
    name: 'string',
    permission: t.union(t.lit('r'), t.lit('w'), t.lit('rw'), t.lit('wr')),
    type: t.opt('string'),
    period: t.opt('string'),
    delta: t.opt('string'),
    number: t.opt('IValueNumber'),
    string: t.opt('IValueString'),
    blob: t.opt('IValueBlob'),
    xml: t.opt('IValueXml'),
});

export const IValueNumber = t.iface([], {
    min: 'number',
    max: 'number',
    step: 'number',
    unit: t.opt('string'),
    si_conversion: t.opt('string'),
    mapping: t.opt('any'),
    ordered_mapping: t.opt('boolean'),
    meaningful_zero: t.opt('boolean'),
});

export const IValueString = t.iface([], {
    max: 'number',
    encoding: t.opt('string'),
});

export const IValueBlob = t.iface([], {
    max: 'number',
    encoding: t.opt('string'),
});

export const IValueXml = t.iface([], {
    xsd: t.opt('string'),
    namespace: t.opt('string'),
});

export const IState = t.iface([], {
    type: t.union(t.lit('Report'), t.lit('Control')),
    data: t.opt('string'),
    timestamp: t.opt('string'),
});

export const ILogRequest = t.iface([], {
    count: t.opt('number'),
    start: t.opt('Date'),
    end: t.opt('Date'),
});

export const ILogResponse = t.iface([], {
    meta: 'IMeta',
    data: 'any',
    more: 'boolean',
    type: 'string',
});

export const IStreamEvent = t.iface([], {});

export const IStreamModel = t.iface([], {
    path: t.func('string'),
    handleStream: t.func('void', t.param('event', 'IStreamEvent')),
});

export const SignalHandler = t.func('void', t.param('event', 'string'));

export const ServiceHandler = t.func(
    t.union(t.union(t.lit(true), 'undefined'), 'boolean'),
    t.param('event', 'any')
);

export const RequestHandler = t.func('any', t.param('event', 'any'));

export const StreamCallback = t.func('void', t.param('model', 'IStreamModel'));

export const ValueStreamCallback = t.func(
    'void',
    t.param('value', 'IValue'),
    t.param('data', 'string'),
    t.param('timestamp', 'string')
);

export const RefreshStreamCallback = t.func('void', t.param('value', 'IValue'));

const exportedTypeSuite: t.ITypeSuite = {
    IConnection,
    IMeta,
    INetwork,
    INetworkFunc,
    IDevice,
    IDeviceFunc,
    IPermissionModelFunc,
    IModelFunc,
    IValue,
    IValueNumber,
    IValueString,
    IValueBlob,
    IValueXml,
    IState,
    ILogRequest,
    ILogResponse,
    IStreamEvent,
    IStreamModel,
    SignalHandler,
    ServiceHandler,
    RequestHandler,
    StreamCallback,
    ValueStreamCallback,
    RefreshStreamCallback,
};
export default exportedTypeSuite;
